get.closest <- function(site, date) {#
  dd.focal <- dd[dd$Site==site,]#
  if(nrow(dd.focal)==0) return(NA)#
  ## which(unique(dd.#
  ## which()#
  browser()#
}#
mapply(get.closest, site=hill.sites, date=hill.dates)
unique(dd$Date)
dates <- unique(dd$Date)
dates
date-dates
abs(date-dates)
min(abs(date-dates))
closest.date <- dates[which(abs(date-dates)==min(abs(date-dates)))]
closest.date
date
Q
## extract hillary's sites:#
load('~/Dropbox/hedgerow/data_sets/traditional/specimens-complete.RData')#
dd$Date <- as.Date(dd$Date, '%Y-%m-%d')#
#
dd.hill <- read.csv('~/Desktop/HillarysSites.csv', as.is=TRUE)#
hill.dates <- as.Date(dd.hill$DateEtrap, '%m/%d/%y')#
hill.sites <- dd.hill$Site#
#
get.closest <- function(site, date) {#
  dd.focal <- dd[dd$Site==site,]#
  if(nrow(dd.focal)==0) return(NA)#
  dates <- unique(dd.focal$Date)#
  closest.date <- dates[which(abs(date-dates)==min(abs(date-dates)))]#
  dd.focal[dd.focal$Date==closest.date,]#
}#
mapply(get.closest, site=hill.sites, date=hill.dates)
subsets <- mapply(get.closest, site=hill.sites, date=hill.dates)
which(is.na(substes))
which(is.na(subsets))
missing <- which(is.na(subsets))#
substes <- subsets[!missing]
subsets <- subsets[!missing]#
new.data.set <- do.call(rbind, subsets)
new.data.set
subsets <- subsets[!missing]
subsets
## extract hillary's sites:#
load('~/Dropbox/hedgerow/data_sets/traditional/specimens-complete.RData')#
dd$Date <- as.Date(dd$Date, '%Y-%m-%d')#
#
dd.hill <- read.csv('~/Desktop/HillarysSites.csv', as.is=TRUE)#
hill.dates <- as.Date(dd.hill$DateEtrap, '%m/%d/%y')#
hill.sites <- dd.hill$Site#
#
get.closest <- function(site, date) {#
  dd.focal <- dd[dd$Site==site,]#
  if(nrow(dd.focal)==0) return(NA)#
  dates <- unique(dd.focal$Date)#
  closest.date <- dates[which(abs(date-dates)==min(abs(date-dates)))]#
  dd.focal[dd.focal$Date==closest.date,]#
}#
subsets <- mapply(get.closest, site=hill.sites, date=hill.dates)#
## locate sites with no corresponding specimen data#
missing <- which(is.na(subsets))#
subsets <- subsets[!missing]
lapply(subsets, dim)
subsets
subsets <- mapply(get.closest, site=hill.sites, date=hill.dates)
length(subsets)
missing <- which(is.na(subsets))
missing
?mapply
## extract hillary's sites:#
load('~/Dropbox/hedgerow/data_sets/traditional/specimens-complete.RData')#
dd$Date <- as.Date(dd$Date, '%Y-%m-%d')#
#
dd.hill <- read.csv('~/Desktop/HillarysSites.csv', as.is=TRUE)#
hill.dates <- as.Date(dd.hill$DateEtrap, '%m/%d/%y')#
hill.sites <- dd.hill$Site#
#
get.closest <- function(site, date) {#
  dd.focal <- dd[dd$Site==site,]#
  if(nrow(dd.focal)==0) return(NA)#
  dates <- unique(dd.focal$Date)#
  closest.date <- dates[which(abs(date-dates)==min(abs(date-dates)))]#
  dd.focal[dd.focal$Date==closest.date,]#
}#
subsets <- mapply(get.closest, site=hill.sites, date=hill.dates,#
                  SIMPLIFY=FALSE)#
## locate sites with no corresponding specimen data#
missing <- which(is.na(subsets))#
subsets <- subsets[[!missing]]
subsets <- mapply(get.closest, site=hill.sites, date=hill.dates,#
                  SIMPLIFY=FALSE)
missing
missing <- which(is.na(subsets))#
subsets <- subsets[-missing]
new.data.set <- do.call(rbind, subsets)
dim(new.data.set)
head(new.data.set)
16001-#
1565-#
1954
load('~/Dropbox/occupancy/analyses/multi-species/multi-season/saved/no_rand_yr_effect/complete/baci/net/bee.syr/full-1.RData')
names(res)
names(res$data)
res$data$dprime.actual
res$data$dprime
plot(res$data$dprime.actual, res$data$dprime)
14701-#
1565-#
1940+#
628
14701-#
1565-#
1940+#
628+1300
1500*0.05
18000+8500
365/40
620-72
26425-#
2083+#
620
356*0.02
26425-#
2159+#
620
20.84+18.94+74.95+356.93+14.99+70
load('~/Dropbox/ccb_banding/analyses/recapture/saved/jags/WRMA-summary.RData')
rows <- c('p',#
          'phi.cover',#
          'phi.0',#
          'phi[1]',#
          'phi[2]',#
          'phi[3]',#
          'phi[4]') ## params to look at#
cols <- c('mean', '2.5%', '97.5%', 'Rhat', 'n.eff')#
summary$bugs[rows,cols]
load(sprintf('analyses/recapture/saved/jags/%s-summary.RData', species))#
rows <- c('p',#
          'decay.forest',#
          'phi.0',#
          'phi[1]',#
          'phi[2]',#
          'phi[3]',#
          'phi[4]') ## params to look at#
cols <- c('mean', '2.5%', '97.5%', 'Rhat', 'n.eff')#
summary$bugs[rows,cols]#
## ************************************************************
summary$bugs
load(sprintf('analyses/recapture/saved/jags/%s-summary.RData', species))#
rows <- c('p[1]',#
          'decay.forest',#
          'phi.0',#
          'phi[1]',#
          'phi[2]',#
          'phi[3]',#
          'phi[4]') ## params to look at#
cols <- c('mean', '2.5%', '97.5%', 'Rhat', 'n.eff')#
summary$bugs[rows,cols]#
## ************************************************************
load(sprintf('analyses/recapture/saved/jags/%s-summary.RData', species))#
rows <- c('p[1]',#
          'decay.forest',#
          'phi.0',#
          'phi.forest',#
          'psi') ## params to look at#
cols <- c('mean', '2.5%', '97.5%', 'Rhat', 'n.eff')#
summary$bugs[rows,cols]#
## ************************************************************
3264*2448
18.63+5+0.56
27849+880
28729-#
1565
27849+880
27849+880-1565
545/4000
88+55
88+50
88+50+33+33
83+50+33+33
88+50+33+33
409/8
40*51*52
29054-#
214
210/60
mean(c(10*12,7,1,1)
mean(c(10*12,7,1,1))
mean(c(10*12,7,1,1))/12
mean(c(10*12,7,1))/12
mean(c(10*12,7,1,1))/12
mean(c(10*12,17,8,7))/12
mean(c(10*12,12,8,7))/12
mean(c(10*12,24,18,17))/12
8367/3
52*0.75
39/2
2789*19
2789*19-2000*12
8367*19
56578*2+50575
56578*2+50575+15000
37207-777
4097*1.2
4097*2
4097.7*2
4097.7*12*0.75
4097.7*52*0.75
3687.93*52*0.75
3687.93*52/2*0.75
(3687.93+409.77)*52/2*0.75
3687.93+409.77
4097.7/80
2356.44*80/64
2945.55*52/2*0.75
2945.55*52/2*0.75-1565*5-1600*4-800
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0
rm(list=ls())#
#
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')
ls()
x<-
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')
names(x)
x
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0
summary(attributes(mod.lam))
## Whether model has lambda paramter or not, used to decide which#
## likelihood calculation to use in jags.LL function below#
attr(mod.lam, "model.case")
attr(mod.lam, "jags.mod")
attr(mod.lam, "lik.vals")
attr(mod.lam, "stat.sum")
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
rm(list=ls())#
#
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')#
###
## -or-#
###
## Correctly estimates lambda at 0, but still thinks a model with#
## lambda estimated is better than one where lambda is set to 0.#
load('~/Desktop/POM_mods_lambda_0_nsp_32_V7.rdata') #
#
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0#
#
## Some Rhats are high, but are for spp with occupancy intercepts#
## (psi.0.sp) near 1 or 0 when passed through logit link.#
#
## Additional Model properties are stored as attributes#
summary(attributes(mod.lam))#
#
## Whether model has lambda paramter or not, used to decide which#
## likelihood calculation to use in jags.LL function below#
attr(mod.lam, "model.case")#
#
## Post-dclone jags model output, monitoring random effects. Acts as#
## input for jags.LL function below#
attr(mod.lam, "jags.mod")#
#
## Vector of simulated likelihood values. Output of jags.LL#
## function. These models were run with 1 million draws.#
attr(mod.lam, "lik.vals")#
#
## Summary of likelihood statistics. Output of jags.LL function.#
attr(mod.lam, "stat.sum")#
#
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
warnings()
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
Q
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
expit
model.case <- attr(dclone.mod, "model.case")#
  jags.mod <- attr(dclone.mod, "jags.mod")
model.case
jags.mod
prms <- jags.mod$data
chains <- jags.mod$bugs$BUGSoutput$sims.matrix
## mean vector#
  mu.vec <- colMeans(chains)#
  ## variance-covariance matrix#
  vcov.mat <- cov(chains)
Q
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
random.draws <- mvrnorm(n=draw.num, mu=mu.vec, Sigma=vcov.mat)
random.draws
Q
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
mod.lam
mod.null <- jags.LL(mod.null,#
                    draw.num=100,#
                    num.cores=4,#
                    detection=T)
mod.null
rm(list=ls())#
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')#
###
## -or-#
###
## Correctly estimates lambda at 0, but still thinks a model with#
## lambda estimated is better than one where lambda is set to 0.
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0#
#
## Some Rhats are high, but are for spp with occupancy intercepts#
## (psi.0.sp) near 1 or 0 when passed through logit link.#
#
## Additional Model properties are stored as attributes#
summary(attributes(mod.lam))#
#
## Whether model has lambda paramter or not, used to decide which#
## likelihood calculation to use in jags.LL function below#
attr(mod.lam, "model.case")#
#
## Post-dclone jags model output, monitoring random effects. Acts as#
## input for jags.LL function below#
attr(mod.lam, "jags.mod")#
#
## Vector of simulated likelihood values. Output of jags.LL#
## function. These models were run with 1 million draws.#
attr(mod.lam, "lik.vals")#
#
## Summary of likelihood statistics. Output of jags.LL function.#
attr(mod.lam, "stat.sum")#
#
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
mod.null <- jags.LL(mod.null,#
                    draw.num=100,#
                    num.cores=4,#
                    detection=T)
rm(list=ls())#
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0#
#
## Some Rhats are high, but are for spp with occupancy intercepts#
## (psi.0.sp) near 1 or 0 when passed through logit link.#
#
## Additional Model properties are stored as attributes#
summary(attributes(mod.lam))#
#
## Whether model has lambda paramter or not, used to decide which#
## likelihood calculation to use in jags.LL function below#
attr(mod.lam, "model.case")#
#
## Post-dclone jags model output, monitoring random effects. Acts as#
## input for jags.LL function below#
attr(mod.lam, "jags.mod")#
#
## Vector of simulated likelihood values. Output of jags.LL#
## function. These models were run with 1 million draws.#
attr(mod.lam, "lik.vals")#
#
## Summary of likelihood statistics. Output of jags.LL function.#
attr(mod.lam, "stat.sum")#
#
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
mod.null <- jags.LL(mod.null,#
                    draw.num=100,#
                    num.cores=4,#
                    detection=T)
rm(list=ls())#
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0#
#
## Some Rhats are high, but are for spp with occupancy intercepts#
## (psi.0.sp) near 1 or 0 when passed through logit link.#
#
## Additional Model properties are stored as attributes#
summary(attributes(mod.lam))#
#
## Whether model has lambda paramter or not, used to decide which#
## likelihood calculation to use in jags.LL function below#
attr(mod.lam, "model.case")#
#
## Post-dclone jags model output, monitoring random effects. Acts as#
## input for jags.LL function below#
attr(mod.lam, "jags.mod")#
#
## Vector of simulated likelihood values. Output of jags.LL#
## function. These models were run with 1 million draws.#
attr(mod.lam, "lik.vals")#
#
## Summary of likelihood statistics. Output of jags.LL function.#
attr(mod.lam, "stat.sum")#
#
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
mod.null <- jags.LL(mod.null,#
                    draw.num=100,#
                    num.cores=4,#
                    detection=T)
mod.lam
mod.null
rm(list=ls())#
library('ape')#
library('dclone')#
library('geiger')#
library('MASS')#
library('phytools')#
library('scales')#
#
## Load Model data#
###
## Correctly identifies phylogenetic signal#
load('~/Desktop/POM_mods_lambda_0.5_nsp_32_V1.rdata')
## Parameter estimates for both models.#
summary(mod.lam) # Lambda estimated#
summary(mod.null) # Lambda=0#
#
## Some Rhats are high, but are for spp with occupancy intercepts#
## (psi.0.sp) near 1 or 0 when passed through logit link.#
#
## Additional Model properties are stored as attributes#
summary(attributes(mod.lam))#
#
## Whether model has lambda paramter or not, used to decide which#
## likelihood calculation to use in jags.LL function below#
attr(mod.lam, "model.case")#
#
## Post-dclone jags model output, monitoring random effects. Acts as#
## input for jags.LL function below#
attr(mod.lam, "jags.mod")#
#
## Vector of simulated likelihood values. Output of jags.LL#
## function. These models were run with 1 million draws.#
attr(mod.lam, "lik.vals")#
#
## Summary of likelihood statistics. Output of jags.LL function.#
attr(mod.lam, "stat.sum")#
#
## Running jags.LL function to caluclate LLs for specified number of#
## random draws. Functions currently set to add attributes of#
## likelihood values for all simulations, and a set of statistical#
## summaries based on those likelihoods, to the original model#
## object. Detection here should always be TRUE since imperfect#
## detection is included in all these models.#
source('~/Desktop/functions.R')#
#
mod.lam <- jags.LL(dclone.mod=mod.lam,#
                   draw.num=100,#
                   num.cores=4,#
                   detection=T)
probs.matrix <- matrix(c(0.1, 0.1,   0,#
                         0.3,   0, 0.2,#
                         0,   0.2, 0.1), nrow=3)
probs.matrix
sum(probs.matrix)
length(probs.matrix)
## suppose we want 3 interactions and we have the following#
## probability matrix#
probs.matrix <- matrix(c(0.1, 0.1,   0,#
                         0.3,   0, 0.2,#
                         0,   0.2, 0.1), nrow=3)#
sample(1:length(probs.matrix), 3, replace=FALSE)
## suppose we want 3 interactions and we have the following#
## probability matrix#
probs.matrix <- matrix(c(0.1, 0.1,   0,#
                         0.3,   0, 0.2,#
                         0,   0.2, 0.1), nrow=3)#
sample(1:length(probs.matrix), 3, replace=FALSE, prob=probs.matrix)
## suppose we want 3 interactions and we have the following#
## probability matrix#
probs.matrix <- matrix(c(0.1, 0.1,   0,#
                         0.3,   0, 0.2,#
                         0,   0.2, 0.1), nrow=3)#
ones <- sample(1:length(probs.matrix), 3, replace=FALSE,#
               prob=probs.matrix)#
res.matrix(matrix(0, nrow=3, ncol=3))#
res.matrix[ones] <- 1
## suppose we want 3 interactions and we have the following#
## probability matrix#
probs.matrix <- matrix(c(0.1, 0.1,   0,#
                         0.3,   0, 0.2,#
                         0,   0.2, 0.1), nrow=3)#
ones <- sample(1:length(probs.matrix), 3, replace=FALSE,#
               prob=probs.matrix)#
res.matrix <- matrix(0, nrow=3, ncol=3)#
res.matrix[ones] <- 1
res.matrix
?sample
149/182
202/260
15/260
23/182
5*149+23*4+3*3+5*2+2
(5*149+23*4+3*3+5*2+2)/182
(5*202+4*29+3*15+2*6+1*8)/182
(5*202+4*29+3*15+2*6+1*8)/260
(5*149+23*4+3*3+5*2+2)/182
(5*202+4*29+3*15+2*6+1*8)/260
1000/4500
3.99*4
2783-661
2783-661-50
-22-36.8+58.8
-22-36.8+58.8-17.96-25+17.96
-22-36.8+58.8-17.96-25+17.96+39.4
-22-36.8+58.8-17.96-25+17.96+39.5
-22-36.8+58.8-17.96-25+17.96+39.5-17
20*60*3
20*60*3+3*20*30
20*60*3+3*20*30+1500
(20*60*3+3*20*30+1500)*5*52
20*60*3+3*20*30
(20*60*3+3*20*30)*5*52
46.39*0.01
46.39*0.02
420/60
load('~/Downloads/CropPollinatorsComp.Rdata')
x<-load('~/Downloads/CropPollinatorsComp.Rdata')
x
crop.pol
dim(crop.pol)
write.csv(crop.pol, file='~/Desktop/crop_pollinators.cvs')
write.csv(crop.pol, file='~/Desktop/crop_pollinators.csv')
write.csv(crop.pol, file='~/Desktop/crop_pollinators.csv', row.names=FALSE)
load('~/Dropbox/ccb_banding/data/gis/range_mapping/saved/ranges.RData')
x<-load('~/Dropbox/ccb_banding/data/gis/range_mapping/saved/ranges.RData')
x
sp.ranges[[1]]
length(sp.ranges[[1]])
length(sp.ranges[[2]])
length(sp.ranges[[3]])
length(sp.ranges[[4]])
length(sp.ranges[[5]])
length(sp.ranges[[6]])
length(unlist(sp.ranges[[2]]))
40+2.5+2.95+9.25+11.06+22.19
15+2.5+2.95+9.25+11.06+22.19
15+2.5+2.95+9.25+11.06+22.19+60
3100*12
585+30.03
585+30.03+18303
1200*12
1160+411
1160+411+3249.03+765.96
585+30.03
24162*0.9
20000*1.2
24000*1.2
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
mp
Q
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
dimnames(X)
expand.grid(dimnames(X))
head(dimnames(X), 50)
head(expand.grid(dimnames(X)), 50)
head(expand.grid(dimnames(X)), 100)
Q
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
##************************************************************************#
## Importance sampling code for Perry#
##************************************************************************#
rm(list=ls())#
setwd('~/Dropbox/ccb_banding/analyses/occupancy-phylo/for_perry')#
#
library(dclone)#
library(R2jags)#
library(scales)#
#
source('functionsFaster.R') ## These are the functions you sent to us,#
                            ## with a few modifications and additional#
                            ## functions.  Completely new, or updated#
                            ## functions begin on line 411#
#
## compile C code and load resultant .so object#
fn.1 <- 'phyloOccLL.o'#
fn.2 <- 'phyloOccLL.so'#
fn.3 <- 'phyloOccLL.c'#
if(file.exists(fn.1)) file.remove(fn.1)#
if(file.exists(fn.2)) file.remove(fn.2)#
system(sprintf('R CMD SHLIB %s', fn.3))#
dyn.load(fn.2)#
#
## load the data which was simulated with lambda=0.5 and 32 species#
## (lambda=0.5 is important, because as will be shown later, the model#
## with lambda is the less likely model)#
load('~/Dropbox/ccb_banding/analyses/occupancy-phylo/saved/dclone/POM_mods_lambda_0.5_nsp_32_V8.rdata',#
     verbose=TRUE)#
## load('POM_mods_lambda_0.5_nsp_32_V8.rdata', verbose=T)#
#
#####################################################################
## Calculate LL with small number of draws#
#####################################################################
#
## If this is repeated a few times the resulting p-values vary quite #
## a bit#
#
set.seed(1)#
n.batch <- 1#
#
mod.lam <- pom.LL(mod.lam,#
                  n.batches=n.batch,#
                  batch.size=10000,#
                  save.all.LLs=T)#
round(attr(mod.lam,  'stat.sum'), 4)
